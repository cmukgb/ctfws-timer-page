{% extends "base.html" %}

{% load static %}

{% block scripts %}
    <!-- ServerDate JavaScript served from the same server as this file -->
    <script src="{% static 'ServerDate.js' %}"></script>

    <!-- Inserts a <script> containing all the MQTT JavaScript common to this
         and the judges page -->
    {% include "mqtt.html" %}

    <!-- Runtime + Compiler version of Vue 2.x from CDN -->
    <!-- Use production version (vue.min.js) when deploying -->
    {% if DEBUG %}
        <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    {% else %}
        <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.min.js"></script>
    {% endif %}

    <!-- Minified version of vuejs-storage from CDN -->
    <!-- This must be version 1.0.0 as there is a bug in 1.0.1 (the latest as of
         this writing) -->
    <script src="https://cdn.jsdelivr.net/npm/vuejs-storage@1.0.0/dist/vuejs-storage.min.js"></script>

    <script>
      {% if DEBUG %}
          "use strict";
      {% endif %}

      // Timing constants
      var updateUIIntervalTime = 500; // ms
      var serverDateLogInterval = 60 * 1000; // ms

      // If useWords, then convert seconds to
      // "[minus ][H hr[s]][M min[s]]S sec[s]"
      // Otherwise, convert seconds to
      // "[-][H:]M:S"
      function toHMSHelper(time, useWords) {
        var negative = false;
        if (time < 0) {
          negative = true;
          time = time * -1;
        }

        var hours = Math.floor(time / 3600);
        time = time - hours * 3600;
        var minutes = Math.floor(time / 60);
        var seconds = time - minutes * 60;

        if (useWords) {
          var result = "";
          if (hours > 0) {
            result += hours + " hr" + (hours === 1 ? "" : "s") + " ";
          }
          if (minutes > 0) {
            result += minutes + " min" + (minutes === 1 ? "" : "s") + " ";
          }
          // Add seconds if there are any or add "0 secs" if there are no
          // hours and no minutes
          if (seconds > 0 || (minutes <= 0 && hours <= 0)) {
            result += seconds + " sec" + (seconds === 1 ? "" : "s");
          }
          return (negative ? "minus " : "") + result.trim();

        } else {
          var result = "";
          if (hours === 0) {
            result = minutes + ":" + (seconds < 10 ? "0" + seconds : seconds);
          } else {
            result =  hours + ":" + (minutes < 10 ? "0" + minutes : minutes) +
              ":" + (seconds < 10 ? "0" + seconds : seconds);
          }
          return (negative ? "-" : "") + result;

        }
      }

      // Convert seconds to "[-][H:]M:S"
      function toHMS(time) {
        return toHMSHelper(time, false);
      }

      // Convert seconds to "[minus ][H hr[s]][M min[s]]S sec[s]"
      function toHMSWords(time) {
        return toHMSHelper(time, true);
      }

      // Get the server's current Unix time in seconds
      function getServerNow() {
        return Math.round(ServerDate.now() / 1000);
      }

      // Get the client's current Unix time in seconds
      function getClientNow() {
        return Math.round(Date.now() / 1000);
      }

      // Log the ServerDate precision and delta every serverDateLogInterval
      function logServerDate() {
        var delta = ServerDate - new Date();
        console.info("ServerDate delta: " + delta + " ms = " +
          toHMS(delta / 1000));
        console.info("ServerDate precision: +/-" + ServerDate.getPrecision() +
          " ms");
      }

      // Sets the two spans which form the game header text field
      function setGameHeader(firstText, secondText, secondClass) {
        $("#gameHeader1").text(firstText);
        $("#gameHeader2").text(secondText);
        $("#gameHeader2").removeClass();
        $("#gameHeader2").addClass(secondClass);
      }

      // Sets the color of a progress bar
      function setBarColor(barName, color) {
        $(barName).removeClass("progress-bar-success");
        $(barName).removeClass("progress-bar-info");
        $(barName).removeClass("progress-bar-warning");
        $(barName).removeClass("progress-bar-danger");
        $(barName).addClass(color);
      }

      // UI const variables
      // var redFlagsText = "Red has: ";
      // var yellowFlagsText = "Yellow has: ";
      var flagsText = "Total per side: ";

      // UI state variables
      //   Config
      var gameValid = false; // whether the most recent config msg was "none"
      var gameStarttime = 0;
      var setupDuration = 0;
      var numRounds = 0;
      var roundDuration = 0;
      var flagsPerTeam = 0;
      var gameNumber = 0;
      //   Stun Timer
      // var stunStart = 0;
      //   Flags
      // var showFlags = true;
      // var numRedFlags = 0;
      // var numYellowFlags = 0;
      //   Endtime
      var gameEndtime = 0;
      //   Messages
      // var gameMessages = [];

      // Function which updates the page based on the UI state variables
      function updateUI() {
        return;
        var now = getServerNow();

        // Config and Endtime
        if (gameValid) {
          $("#flagsHeader").text(flagsText + flagsPerTeam);

          var setupEnd = gameStarttime + setupDuration;
          var gameEnd = setupEnd + (numRounds * roundDuration); // scheduled end
          var gameDuration = gameEnd - setupEnd;
          var setupEndDate = new Date(setupEnd * 1000);
          var gameStartText = setupEndDate.toLocaleTimeString();
          var numText = gameNumber === 0 ? "State" : gameNumber;

          if ((gameEndtime >= gameStarttime && gameEndtime <= now) ||
              gameEnd <= now) {
            // Over
            setGameHeader("Game " + numText + ": ", "Over", "text-danger");
            var secs = 0;
            var gameEndDate = null;
            if (gameEndtime >= gameStarttime && gameEndtime <= now) {
              secs = Math.max(Math.min(gameEndtime, gameEnd) - setupEnd, 0);
              gameEndDate = new Date(Math.min(gameEndtime, gameEnd) * 1000);
            } else {
              secs = gameEnd - setupEnd;
              gameEndDate = new Date(gameEnd * 1000);
            }
            var gameEndText = gameEndDate.toLocaleTimeString();
            $("#startTimeLabel").text("Game ended at " + gameEndText);
            var roundNum = Math.floor((secs - 1) / roundDuration); // 0-indexed
            var roundSecs = secs - roundNum * roundDuration;
            $("#setupJailbreakLabel").text("Jailbreak " + (roundNum + 1));
            var percent1 = Math.round((100 * roundSecs) / roundDuration);
            $("#firstBar").width(percent1 + "%");
            setBarColor("#firstBar", "progress-bar-danger");
            $("#firstBarLabel").text(toHMS(roundSecs) + " / " +
                toHMS(roundDuration));
            var percent2 = Math.round((100 * secs) / gameDuration);
            $("#secondBar").width(percent2 + "%");
            setBarColor("#secondBar", "progress-bar-danger");
            $("#secondBarLabel").text(toHMS(secs) + " / " +
                toHMS(gameDuration));
          } else if (setupEnd <= now) {
            // Playing
            setGameHeader("Game " + numText + ": ", "In Progress",
                "text-success");
            $("#startTimeLabel").text("Game started at " + gameStartText);
            var secs = now - setupEnd;
            var roundNum = Math.floor((secs - 1) / roundDuration); // 0-indexed
            var roundSecs = secs - roundNum * roundDuration;
            $("#setupJailbreakLabel").text("Jailbreak " + (roundNum + 1));
            var percent1 = Math.round((100 * roundSecs) / roundDuration);
            $("#firstBar").width(percent1 + "%");
            setBarColor("#firstBar", "progress-bar-warning");
            $("#firstBarLabel").text(toHMS(roundSecs) + " / " +
                toHMS(roundDuration));
            var percent2 = Math.round((100 * secs) / gameDuration);
            $("#secondBar").width(percent2 + "%");
            setBarColor("#secondBar", "progress-bar-success");
            $("#secondBarLabel").text(toHMS(secs) + " / " +
                toHMS(gameDuration));
          } else {
            // Setup
            setGameHeader("Game " + numText + ": ", "Setup", "text-info");
            $("#startTimeLabel").text("Game starts at " + gameStartText);
            $("#setupJailbreakLabel").text("Setup");
            var secs = now - gameStarttime;
            var percent = Math.round((100 * secs) / setupDuration);
            $("#firstBar").width(percent + "%");
            setBarColor("#firstBar", "progress-bar-info");
            $("#firstBarLabel").text(toHMS(secs) + " / " +
                toHMS(setupDuration));
            $("#secondBar").width("0%");
            setBarColor("#secondBar", "progress-bar-success");
            $("#secondBarLabel").text(toHMS(0) + " / " + toHMS(gameDuration));
          }

        } else {
          // No Game
          setGameHeader("No Current Game", "", "");
          $("#startTimeLabel").text("");
          $("#setupJailbreakLabel").text("Setup");
          $("#firstBar").width("0%");
          setBarColor("#firstBar", "progress-bar-danger");
          $("#firstBarLabel").text("0:00 / 15:00");
          $("#secondBar").width("0%");
          setBarColor("#secondBar", "progress-bar-danger");
          $("#secondBarLabel").text("0:00 / 1:00:00");
          $("#flagsHeader").text(flagsText + "0");
        }

        // Stun Timer
        //if (stunStart > 0) {
          // Stun active or over
          // $("#stunRow").removeClass("hidden");
          // var stunLength = 60
          // var secs = Math.min(now - stunStart, stunLength);
          // var percent = Math.round((100 * secs) / stunLength);
          // $("#stunBar").width(percent + "%");
          // $("#stunBarLabel").text(toHMS(secs) + " / " + toHMS(stunLength));
          // if (percent < 100) {
          //   $("#cancelButton").text("Cancel");
          // } else {
          //   $("#cancelButton").text("Done");
          // }
          // $("#stunButtonRow").addClass("hidden");
          // $("#cancelButtonRow").removeClass("hidden");
        //} else {
          // No stun
          // $("#stunRow").addClass("hidden");
          // $("#cancelButtonRow").addClass("hidden");
          // $("#stunButtonRow").removeClass("hidden");
          // $("#stunBar").width("0%");
        //}

        // Flags
        // if (showFlags) {
          // $("#redFlagsHeader").text(redFlagsText + numRedFlags);
          // $("#yellowFlagsHeader").text(yellowFlagsText + numYellowFlags);
        // } else {
          // $("#redFlagsHeader").text(redFlagsText + "?");
          // $("#yellowFlagsHeader").text(yellowFlagsText + "?");
        // }

        // Messages
        // var firstRow = '<tr><th class="col-sm-2 col-xs-2">Time<\/th>' +
        //   '<th>Message<\/th><\/tr>';
        // $("#messageTable").html(firstRow);
        for (var i = gameMessages.length - 1; i >= 0; i--) {
          var secs = gameMessages[i][0];
          var time = (new Date(secs * 1000)).toLocaleTimeString();
          var color = "";
          if (gameValid) {
            var setupEnd = gameStarttime + setupDuration;
            var gameEnd = setupEnd + (numRounds * roundDuration); // scheduled end
            var cutoff = 0;
            if (gameEndtime >= gameStarttime && gameEndtime <= now) {
              cutoff = Math.min(gameEndtime, gameEnd);
            } else {
              cutoff = gameEnd;
            }
            if (secs < gameStarttime) {
              color = "active";
            } else if (secs < setupEnd) {
              color = "info";
            } else if (secs < cutoff) {
              color = "success";
            } else {
              color = "danger";
            }
          }
          // var newRow = '<tr class="' + color + '"><td>' + time + '<\/td><td>' +
          //   gameMessages[i][1] + '<\/td><\/tr>';
          // $("#messageTable").append(newRow);
        }
      }

      // Compare messages by timestamp such that sorting will put them in order
      // from newest to oldest
      function compareMessages(a, b) {
        return b[0] - a[0];
      }

      function messageInList(msg, msgList) {
        for (var i = 0; i < msgList.length; i++) {
          if (msg[0] === msgList[i][0] && msg[1] === msgList[i][1]) {
            return true;
          }
        }
        return false;
      }

      // Called when an MQTT message arrives
      function onMessageArrived(message) {
        console.info("onMessageArrived: " + message.destinationName + ": " +
            message.payloadString);

        return;

        var msg = message.payloadString;
        var topic = message.destinationName.substring(11);
        switch (topic) {
          case 'config':
            if (msg === "none") {
              gameValid = false;
            } else {
              var split = splitOnWhitespace(msg, 6);
              var start = parseInt(split[0]);
              var setup = parseInt(split[1]);
              var rounds = parseInt(split[2]);
              var roundlen = parseInt(split[3]);
              var flags = split[4];
              var game = split[5];
              if (!isNaN(start) && !isNaN(setup) && !isNaN(rounds) &&
                  !isNaN(roundlen)) {
                gameStarttime = start;
                setupDuration = setup;
                numRounds = rounds;
                roundDuration = roundlen;
                flagsPerTeam = flags;
                gameNumber = game;
                gameValid = true;
              } else {
                console.error("Unknown config message: " + msg);
              }
            }
            break;
          case 'flags':
            if (msg === "?") {
              showFlags = false;
            } else {
              var split = splitOnWhitespace(msg, 2);
              var r = parseInt(split[0]);
              var y = parseInt(split[1]);
              if (!isNaN(r) && !isNaN(y)) {
                numRedFlags = r;
                numYellowFlags = y;
                showFlags = true;
              } else {
                console.error("Unknown flag message: " + msg);
              }
            }
            break;
          case 'endtime':
            var secs = parseInt(msg);
            if (!isNaN(secs)) {
              gameEndtime = secs;
            } else {
              colsole.log("Unknown endtime message: " + msg);
            }
            break;
          case 'message':
          case 'message/player':
            var split = splitOnFirstWhitespace(msg);
            var secs = parseInt(split[0]);
            var body = split[1];
            if (!isNaN(secs)) {
              if (!messageInList([secs, body], gameMessages)) {
                gameMessages.push([secs, body]);
                gameMessages = gameMessages.sort(compareMessages);
              }
            } else {
              console.error("Unknown message message: " + msg);
            }
            break;
          case 'message/jail':
            console.info("Ignoring jail message: " + msg);
            break;
          default:
            console.warn("Unknown topic: " + message.destinationName);
        }

        updateUI();
        // If it took more than 3 seconds to get here this interval will
        // already be set up. Otherwise, start it now.
        if (updateUIIntervalObject === false) {
          updateUIIntervalObject = setInterval(updateUI, updateUIIntervalTime);
        }
      }

      // Vue constants
      var updateNowIntervalTime = 500; // ms
      var clockOffsetThreshold = 15; // seconds

      // TODO deleteme
      var updateUIIntervalObject = false;
      $(document).ready(function() {
        // Log the ServerDate precision and delta
        logServerDate();
        setInterval(logServerDate, serverDateLogInterval);

        // The UI looks cleanest if we don't update it until the MQTT client
        // has connected. So we give it 3 seconds connect before we set up the
        // UI interval. If it connects first, the below variable will still be
        // false and it will set up the interval. If not, we start the interval
        // and if it still connects after 3 seconds, it will not touch the
        // interval.
        updateUIIntervalObject = false; // Intentionally global
        setTimeout(function() {
          if (updateUIIntervalObject === false) {
            updateUI();
            updateUIIntervalObject = setInterval(updateUI, updateUIIntervalTime);
          }
        }, 3 * 1000); // 3 seconds

        Vue.use(vuejsStorage);

        new Vue({
          el: '#app',
          delimiters: ['[[', ']]'],
          data: {
            serverNow: getServerNow(),
            clientNow: getClientNow(),
            stun: {
              start: 0,
              length: 60, // Fixed total length of stun
            },
            flags: {
              show: true,
              numRed: 0,
              numYellow: 0,
            },
          },
          // Used by vuejs-storage: Everything in this.storage.data should work
          // exactly the same as things in this.data (including being available
          // just as this.foo), except data in storage will persist accross page
          // loads, until the browser is restarted (see window.sessionStorage).
          storage: {
            data: {
              messages: [],
            },
            storage: sessionStorage,
            namespace: 'ctfws-timer',
          },
          created: function() {
            // Setup the MQTT client and connect. This function is defined in
            // mqtt.html, which is included above. This defines mqttClient as the
            // global variable for the client connection.
            initMqtt(this.onMessageArrived);

            // Update the "now" variables every updateNowIntervalTime. Vue will
            // react to this change and update all UI that uses them.
            var vm = this;
            setInterval(function() {
              vm.serverNow = getServerNow();
              vm.clientNow = getClientNow();
            }, updateNowIntervalTime);
          },
          computed: {
            serverClientDelta: function() {
              return this.serverNow - this.clientNow;
            },
            serverClientAbsDelta: function() {
              return Math.abs(this.serverClientDelta);
            },
            showOffset: function() {
              // Check if the server time is different from the client time by
              // more than clockOffsetThreshhold seconds. If so, warn the user.
              return this.serverClientAbsDelta > clockOffsetThreshold;
            },
            now: function() {
              return this.serverNow;
            },
            stunElapsed: function() {
              return Math.min(this.now - this.stun.start, this.stun.length);
            },
            stunPercent: function() {
              return Math.round((100 * this.stunElapsed) / this.stun.length);
            },
            sortedMessages: function() {
              return this.messages.sort(compareMessages);
            },
          },
          methods: {
            clickStun: function() {
              console.info("onStunButtonClick");
              this.stun.start = this.now;
            },
            clickCancel: function() {
              console.info("onCancelButtonClick");
              this.stun.start = 0;
            },
            onMessageArrived: function(message) {
              console.info("onMessageArrived: " + message.destinationName +
                  ": " + message.payloadString);

              var msg = message.payloadString;
              var topic = message.destinationName.substring(
                  "ctfws/game/".length);
              switch (topic) {
                // case 'config':
                //   if (msg === "none") {
                //     gameValid = false;
                //   } else {
                //     var split = splitOnWhitespace(msg, 6);
                //     var start = parseInt(split[0]);
                //     var setup = parseInt(split[1]);
                //     var rounds = parseInt(split[2]);
                //     var roundlen = parseInt(split[3]);
                //     var flags = split[4];
                //     var game = split[5];
                //     if (!isNaN(start) && !isNaN(setup) && !isNaN(rounds) &&
                //         !isNaN(roundlen)) {
                //       gameStarttime = start;
                //       setupDuration = setup;
                //       numRounds = rounds;
                //       roundDuration = roundlen;
                //       flagsPerTeam = flags;
                //       gameNumber = game;
                //       gameValid = true;
                //     } else {
                //       console.error("Unknown config message: " + msg);
                //     }
                //   }
                //   break;
                case 'flags':
                  if (msg === "?") {
                    this.flags.show = false;
                  } else {
                    var split = splitOnWhitespace(msg, 2);
                    var r = parseInt(split[0]);
                    var y = parseInt(split[1]);
                    if (!isNaN(r) && !isNaN(y)) {
                      this.flags.numRed = r;
                      this.flags.numYellow = y;
                      this.flags.show = true;
                    } else {
                      console.error("Unknown flag message: " + msg);
                    }
                  }
                  break;
                // case 'endtime':
                //   var secs = parseInt(msg);
                //   if (!isNaN(secs)) {
                //     gameEndtime = secs;
                //   } else {
                //     colsole.log("Unknown endtime message: " + msg);
                //   }
                //   break;
                case 'message':
                case 'message/player':
                  var split = splitOnFirstWhitespace(msg);
                  var secs = parseInt(split[0]);
                  var body = split[1];
                  if (!isNaN(secs)) {
                    if (secs === 1) {
                      // Somewhat "hidden" feature to force clients to clear
                      // their message list in case the judge really needs to
                      // recall a message. If secs is exactly 1, the list is
                      // cleared and the message is ignored.
                      this.messages = []
                    } else if (!messageInList([secs, body], this.messages)) {
                      this.messages.push([secs, body]);
                    }
                  } else {
                    console.error("Unknown message message: " + msg);
                  }
                  break;
                case 'message/jail':
                  console.info("Ignoring jail message: " + msg);
                  break;
                default:
                  console.warn("Unknown topic: " + message.destinationName);
              }
            },
          },
          filters: {
            toHMS: toHMS,
            toHMSWords: toHMSWords,
            secsToLocaleTimeString: function(secs) {
              return new Date(secs * 1000).toLocaleTimeString();
            }
          },
          mounted: function() {
            // All initial jQuery needs to be done in here, after Vue has set up
            // the DOM

            // Mobile Safari has a bug that prevents popovers from closing when
            // the user taps away from them. This can be fixed with the below
            // CSS, but we only want to do this when needed because if the
            // device does have a mouse, it makes the mouse always the
            // "clickable" style pointer.
            if (/iPad|iPhone|iPod/.test(navigator.userAgent) &&
                !window.MSStream) {
              $("body").css("cursor", "pointer");
            }

            // Enable the popover on the "What's this?" shown when there is a
            // clock offset.
            $("#offsetPopover").popover();
          },
        });

        console.info("Finished setup");
      });
    </script>
{% endblock %}

{% block page_title %}
    <span id="gameHeader1">Connecting...</span>
    <span id="gameHeader2"></span>
{% endblock %}

{% block container %}
    <div id="app">

      <div class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-10 col-xs-12">
          <p id="startTimeLabel" class="lead text-center"></p>
          <p v-show="showOffset" class="text-muted text-center">
            <strong>Note:</strong> Your clock is
            [[ this.serverClientDelta > 0 ? 'behind' : 'ahead of' ]]
            the game's by [[ serverClientAbsDelta | toHMSWords ]].
            <a id="offsetPopover" tabindex="0" role="button"
              data-toggle="popover" data-trigger="focus" data-placement="auto"
              data-html=true data-content=
              "We correct for any difference between your clock
              and the game clock, so you don’t have to do anything for the app
              to work.
              <br>
              However, we still display the game start time and any messages
              using the game clock. Because your clock is off by more than a
              few seconds, this means the times shown may not agree with the
              clock shown on your device."
              >
              What's&nbsp;this?
            </a>
          </p>
        </div>

      </div>
      <div class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-10 col-xs-12">
        </div>

      </div>
      <div class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-2 col-xs-3">
          <p id="setupJailbreakLabel" class="lead text-center">Setup</p>
        </div>

        <div class="col-sm-6 col-xs-6">
          <div class="progress">
            <div id="firstBar" class="progress-bar" role="progressbar"
              style="width: 0%">
            </div>
          </div>
        </div>

        <div class="col-sm-2 col-xs-3">
          <p id="firstBarLabel" class="lead text-center">0:00 / 15:00</p>
        </div>

      </div>
      <div class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-2 col-xs-3">
          <p class="lead text-center">Game Time Elapsed</p>
        </div>

        <div class="col-sm-6 col-xs-6">
          <div class="progress">
            <div id="secondBar" class="progress-bar" role="progressbar"
              style="width: 0%">
            </div>
          </div>
        </div>

        <div class="col-sm-2 col-xs-3">
          <p id="secondBarLabel" class="lead text-center">0:00 / 1:00:00</p>
        </div>

      </div>
      <div v-show="stun.start > 0" class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-2 col-xs-3">
          <p class="lead text-center">Stun Timer</p>
        </div>

        <div class="col-sm-6 col-xs-6">
          <div class="progress">
            <div class="progress-bar progress-bar-info"
              role="progressbar" :style="{ width: stunPercent + '%' }">
            </div>
          </div>
        </div>

        <div class="col-sm-2 col-xs-3">
          <p class="lead text-center">
            [[ stunElapsed | toHMS ]] / [[ stun.length | toHMS ]]
          </p>
        </div>

      </div>
      <div v-show="stun.start > 0" class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-10 col-xs-12 text-center">
          <button class="btn btn-info btn-lg" type="button"
            @click="clickCancel">
            [[ stunPercent < 100 ? 'Cancel' : 'Done' ]]
          </button>
        </div>

      </div>
      <div v-show="stun.start === 0" class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-10 col-xs-12 text-center">
          <button class="btn btn-info btn-lg" type="button"
            @click="clickStun">
            Stun Timer
          </button>
        </div>

      </div>
      <div class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-10 col-xs-12">
          <div class="page-header">
            <h2 class="text-center">Flags</h2>
          </div>
        </div>

      </div>
      <div class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-10 col-xs-12">
          <p class="text-muted text-center">
            Note: The head judge may choose to report a score for each team
            rather than a number of flags.
          </p>
        </div>

      </div>
      <div class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-10 col-xs-12">
          <h3 id="flagsHeader" class="text-center">Total per side: 0</h3>
        </div>

      </div>
      <div class="row vertical-center">

        <div v-show="flags.show" class="col-sm-offset-1 col-sm-5 col-xs-6">
          <h3 class="text-center text-danger">
            Red has: [[ flags.numRed ]]
          </h3>
        </div>

        <div v-show="flags.show" class="col-sm-5 col-xs-6">
          <h3 class="text-center text-warning">
            Yellow has: [[ flags.numYellow ]]
          </h3>
        </div>

        <div v-show="!flags.show" class="col-sm-offset-1 col-sm-10 col-xs-12">
          <h3 class="text-center text-info">
            Team scores hidden
          </h3>
        </div>

      </div>
      <div class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-10 col-xs-12">
          <div class="page-header">
            <h2 class="text-center">Messages</h2>
          </div>
        </div>

      </div>
      <div class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-10 col-xs-12">
          <p>
          <strong>Note:</strong> Messages sent while the browser is inactive may not appear.
          <br>
          Messages sent before game start are
          <span class="text-muted">grey</span>, during setup are
          <span class="text-info">blue</span>, during game play are
          <span class="text-success">green</span>, and after game end are
          <span class="text-danger">red</span>.
          </p>
        </div>

      </div>
      <div class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-10 col-xs-12">
          <table class="table">
            <tr>
              <th class="col-sm-2 col-xs-2">Time</th>
              <th>Message</th>
            </tr>
            <tr v-for="message in sortedMessages" ><!-- :class="TODO" -->
              <td>[[ message[0] | secsToLocaleTimeString ]]</td>
              <td>[[ message[1] ]]</td>
            </tr>
          </table>
        </div>

      </div>

    </div>
{% endblock %}
